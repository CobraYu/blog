看过复仇者联盟的都知道，灭霸作为计划生育政策的坚定支持者和执行者，一个响指清除了宇宙中二分之一的生命。电影中被清除的生命灰飞烟灭的镜头很是酷炫，所以在复联4上映后，那个不存在的网站google，推出了一个彩蛋，如果在搜索框搜索灭霸，会出现一个手套的按钮，点击后会让网页搜索结果消失一半。
![](./image/g.gif)
恩~这很谷歌。  
效果虽然酷炫但其实并不复杂，这里带着大家一起来实现一下，网上也已经有了很多教程，这里稍微加点东西，灭霸的响指毕竟是真的打而不是用鼠标点按钮，所以我会加上音量检测，当检测到响指的声音（其实是超过某个音量预值）就触发效果，然后就可以愉快的向朋友装逼了。

## 准备开始
我们这里只用一个图片元素,HTML结构如下
```HTML
<body>
     <div class="content">
            <div id="image">
                <!-- 图片为网络地址才可在本地通过直接打开html调试 -->
                <img
                    src="https://i.loli.net/2019/05/06/5ccffa469ec52.jpg"
                    width="400"
                />
            </div>
    </div>
</body>
```
## 动画的实现  
1. 将html转成canvas，为后面处理做准备。这里我们使用html2canvas库，可以将html中的dom节点绘制成canvas，相当于对这个dom节点进行截图，使用很简单，代码如下（页面生成海报图片就可以用这个库来做）。
```javascript
const imageBox = document.querySelector('#image')
html2canvas(imageBox, {
    backgroundColor: 'transparent' //背景设置为透明
}).then(canvas=>{
    //处理canvas的代码（注意.then这种写法只有在新版本的html2canvas可用）
});
```
2. 这里我们拿到了包含了图片信息的canvas后，要通过canvas的getImageData来获取到canvas画布上的每个像素的信息。
```javascript
 //处理canvas的代码
const ctx = canvas.getContext('2d');
const imageData = ctx.getImageData(
    0,
    0,
    canvas.width,
    canvas.height
);
const pixelArr = imageData.data; //像素信息
```
> 图像信息被存储在一个Uint8ClampedArray（8位无符号整型固定数组）中，这个数组中的值为0到255的整数，按图片中像素从左到右从上到下的顺序，每4个数字表示一个像素信息，这4个数字分别表示rgba（r-红色，g-绿，b-蓝色，a-透明度）的四个值。
> 比如这样一个图片  
> ![](./image/color.jpg)  
> 它的像素信息即为
> ```javascript
> [0,0,0,255,255,255,255,255,255,0,0,255,0,255,0,255]
> ```
3. 接下来是最关键的一步，创建多个同等长度的数组，填充上透明像素信息，然后将之前拿到的图像像素信息“随机”分布到这些数组中。
```javascript
//创建一个和图像信息数组大小相同的数组并填充0（相当于一个和原图像尺寸相同的透明图像）
const data = pixelArr.slice(0).fill(0); 
//创建透明图像数组的个数
const canvasCount = 30;
//将透明图像数组复制多个
const imageDataArray = Array.from({ length: canvasCount }, () =>
    data.slice(0)
);
//将原图像上的像素信息随机分配进不同的透明图象上，位置保持不变
for (let i = 0; i < pixelArr.length; i += 4) {
    //随机选出要放入像素信息的数组
    const p = Math.floor((i / pixelArr.length) * canvasCount);
    //weightedRandomDistrib(p, canvasCount)会随机返回一个0-30之间的随机数，但并非完全随机。
    const a = imageDataArray[weightedRandomDistrib(p, canvasCount)];
    //将像素信息放入随机到的透明图像数组中覆盖
    a[i] = pixelArr[i];
    a[i + 1] = pixelArr[i + 1];
    a[i + 2] = pixelArr[i + 2];
    a[i + 3] = pixelArr[i + 3];
}

```